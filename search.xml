<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql-架构</title>
      <link href="/2025/05/17/mysql-%E6%9E%B6%E6%9E%84/"/>
      <url>/2025/05/17/mysql-%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h1><h2 id="1-总体概述"><a href="#1-总体概述" class="headerlink" title="1.总体概述"></a>1.总体概述</h2><p>Mysql简单来说可以分成两层：</p><ul><li>server层</li><li>执行引擎层</li></ul><p>server层：负责与客户端建立连接，分析、优化、执行sql语句<br>存储引擎层：负责数据的存储与读取</p><blockquote><p>简单来理解就是，server层是大脑，通过分析sql语句让存储引擎层（执行者）去做存储或读取数据</p></blockquote><h2 id="2-核心组件"><a href="#2-核心组件" class="headerlink" title="2. 核心组件"></a>2. 核心组件</h2><h3 id="2-1-server层"><a href="#2-1-server层" class="headerlink" title="2.1 server层"></a>2.1 server层</h3><ul><li><p>连接器<br>首先我们使用mysql第一步就是与mysql服务器建立连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h&lt;ip&gt; -u&lt;user&gt; -p  </span><br></pre></td></tr></table></figure><p>这一步就是建立服务器连接，mysql连接是tcp形式的(长连接&#x2F;连接池优化)</p><blockquote><p>连接池：一种池化思想，通过预先创建连接，避免反复创建连接产生的握手开销<br>上面提到了长连接优化，但是长连接也有它的弊端，mysql在断开连接的时候才会释放连接的内存资源，因此长连接可能导致占用了大量的内存资源：</p></blockquote><ul><li>定期断开长连接</li><li>mysql5.7后当客户端执行了一个很大的操作后，会调用reset函数重置连接</li></ul></li><li><p>查询缓存<br>当连接建立完成之后，客户端就可以发送sql语句进行查询了，如果sql是select语句(查询)，那么就首先会查询缓存，这查询缓存是以key-value的形式存储在内存中的，key为sql查询语句，value为sql查询的结果。但实际上，这个缓存挺没有用的(命中率低), 因此在mysql8.0后就舍弃了查询缓存，<strong>注意这里指的是server层中的缓存，执行引擎中还有bufferpool作为缓存</strong></p></li><li><p>解析器<br>进行词法分析和语法分析</p></li><li><p>执行sql</p><blockquote><p>该阶段分为三个部份：</p><ul><li>预处理</li><li>优化</li><li>执行</li></ul></blockquote><ol><li><p>预处理阶段主要做了两件工作：</p><ul><li>检查sql语句中的字段是否存在</li><li>将select * 中的 * 字段，拓展为表上的所有列</li></ul></li><li><p>优化器<br>  这里详细介绍一下优化器：<br>  Mysql的优化器是优化sql查询的核心组件，本质上是寻找最优解的过程，具体来说就是将客户端的sql语句，转化成最佳的物理执行逻辑<br>  <strong>作用</strong>  </p><ul><li>选择最佳执行路径：在多种可能的查询方式中选择最优解(全表扫描、索引扫描等)</li><li>生成执行计划：将sql语句转化为具体的物理执行计划</li><li>动态适应数据变化：根据表的统计信息动态调整执行计划<br>  <strong>优化器类型</strong></li><li>基于规则的优化器(已弃用)</li><li>基于代价的优化器<br><strong>核心公式：cost &#x3D; cpu + io</strong> 也就是考虑读取数据和读取数据行的成本<br>通过表统计信息，估算扫描行数，索引选择性<br>支持查询重写和多表连接顺序优化</li><li>优化器关键优化策略  <ol><li>索引选择</li><li>连接优化</li><li>子查询优化</li><li>查询重写</li><li>排序优化</li></ol></li><li>统计信息与直方图  <ol><li>表统计信息</li><li>索引统计信息</li><li>直方图</li></ol></li></ul><p> <strong>关于优化器的部份可以看我做的simple-db优化部份</strong></p><p> <strong>索引下推</strong><br> 索引下推可以减少二级索引回表的开销，提高查询的效率，具体来说他将Server层做的判断下放到执行引擎层执行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设想一个查询语句：</span><br><span class="line">select * where age &gt; 20 and sex = &#x27;男&#x27;</span><br><span class="line">对于这么一个表，我们在age，sex上建立了二级索引，没有索引下推时，我们需要根据age的索引查到记录，然后进行回表，最后到server层中判断sex是否为男，在有索引下推时，可以将sex = ‘男’提前到执行引擎层判断，在找到对应的索引时检查直接检查sex而不是先回表，这样减少了回表的开销</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="2-2-执行引擎层"><a href="#2-2-执行引擎层" class="headerlink" title="2.2 执行引擎层"></a>2.2 执行引擎层</h3><blockquote><p>在本节我们讨论数据库中数据的存放</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习日记-week1</title>
      <link href="/2025/05/17/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0-week1/"/>
      <url>/2025/05/17/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0-week1/</url>
      
        <content type="html"><![CDATA[<h1 id="实习日记-week1"><a href="#实习日记-week1" class="headerlink" title="实习日记-week1"></a>实习日记-week1</h1><p>经过了上周的onboarding week，这周正式进入业务部门，我们部门是写node的，主要做gloabl的发票业务，听另一个实习生说架构很复杂，还有投入AI agent的探索, 这里是比较感兴趣的。mentor人很好，但是一幅命苦打工人的样子(lol)，真正与同事接触才发现自己交际能力真的不太行，但是还是要好好相处呀</p><p>这周学习</p><ul><li>node</li><li>js</li><li>一个简单的oss工具</li></ul><p>下周预期开始学习cap，公司的后端框架，希望能早点接触到业务代码</p><p>不管怎么样，踏踏实实走好每一步，不然机会来临时都无法把握住，好好学习！！</p>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>认识node.js</title>
      <link href="/2025/05/12/%E8%AE%A4%E8%AF%86node-js/"/>
      <url>/2025/05/12/%E8%AE%A4%E8%AF%86node-js/</url>
      
        <content type="html"><![CDATA[<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><blockquote><p>First of all， Node is not a programming language but its runtime env for executing js code</p></blockquote><p>node的一个很大优势就是异步，如何理解：<br>对于一个常见的web应用，一个request对应一个线程，如果那么并发数限制于最大线程数。<br>但是node后端来说，他是异步的，在对数据库操作时，可以不被阻塞，而是处理另一个request</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP-爬楼梯</title>
      <link href="/2025/05/12/DP-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2025/05/12/DP-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2025/05/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2025/05/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] fa; <span class="comment">// 代表元</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] size; <span class="comment">// 大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> cc; <span class="comment">// 连通块个数</span></span><br><span class="line"></span><br><span class="line">    UnionFind(<span class="type">int</span> n) &#123;</span><br><span class="line">        fa = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">        cc = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回x所在集合的代表元 */</span></span><br><span class="line">    <span class="comment">/* 同时做路径压缩 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x] != x) &#123;</span><br><span class="line">            fa[x] = find(fa[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(from);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> find(to);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        size[y] += size[x];</span><br><span class="line">        cc--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size[find(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说并查集的作用就是把点按连通块分开</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络系统</title>
      <link href="/2025/05/09/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/05/09/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><h3 id="什么是零拷贝？"><a href="#什么是零拷贝？" class="headerlink" title="什么是零拷贝？"></a>什么是零拷贝？</h3><p>磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存10倍以上，所以针对优化磁盘技术非常多，比如零拷贝，直接IO，异步IO等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘告诉缓存区可以有效减少磁盘访问次数</p><h4 id="为什么要有DMA技术？"><a href="#为什么要有DMA技术？" class="headerlink" title="为什么要有DMA技术？"></a>为什么要有DMA技术？</h4><p>在没有DMA技术前，IO的过程是这样的：</p><ul><li>CPU发出对应指令给磁盘控制器，然后返回</li><li>磁盘控制器收到指令后，开始准备数据，会把数据放入到磁盘控制器内部的缓冲区，然后产生一个终端</li><li>CPU收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节的读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输期间CPU是无法执行其他任务的</li></ul><p>因此在进行IO设备和内存的数据传输的时候，数据搬运的工作全部交给DMA控制器，而CPU不再参与任何与数据搬运相关的事情</p><p><strong>具体流程</strong></p><ul><li>用户进程调用read方法,向操作系统发出IO请求，请求读取数据到自己的内存缓冲区，进程进入阻塞状态</li><li>操作系统收到请求后，进一步将IO请求发送DMA，然后让CPU执行其他任务</li><li>DMA进一步将IO请求发送给磁盘</li><li>磁盘收到DMA的IO请求后，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向DMA发起中断信号，告知自己缓冲区已满</li><li>DMA收到磁盘信号，将磁盘控制缓冲区中的数据拷贝到内核缓冲区中，此时不占用CPU，CPU可以执行其他任务</li><li>当DMA读取了足够多的数据后，就会发中断信号给CPU</li><li>CPU收到DMA信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回</li></ul><p>CPU不再参与将数据从磁盘控制缓冲区搬运到内核空间的工作，这部分工作全程由DMA完成。</p><h4 id="服务端的文件传输"><a href="#服务端的文件传输" class="headerlink" title="服务端的文件传输"></a>服务端的文件传输</h4><p>如果服务端要提供文件传输功能，两个步骤：</p><ul><li>将磁盘上的文件读取出来</li><li>通过网络协议发送给客户端</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>期间发生了4次用户态和内核态的上下文切换。<br>4次数据拷贝：其中两次是DMA拷贝，另外两次是通过CPU拷贝:</p><ul><li>第一次拷贝：把磁盘上的数据拷贝到操作系统内核的缓冲区中，于是我们应用程序就可以使用这一部分数据了</li><li>第二次拷贝：把内核缓冲区的数据拷贝到用户缓冲区中，于是我们的应用程序就可以使用这部分数据了</li><li>第三次拷贝：把刚才拷贝到用户缓冲区里的数据，再拷贝到内核的socket的缓冲区里，这个过程依然是CPU搬运的</li><li>第四次拷贝：把内核的socket缓冲区里的数据，拷贝到网卡缓冲区里，这个过程是由DMA拷贝的</li></ul><p>我们可以发现很多次的数据拷贝，同时存在冗余的上下文切换和数据拷贝，多了很多不必要的开销，影响系统性能。<br>所以，要提高文件传输的性能，必须减少用户态和内核态的上下文切换和内存拷贝的次数</p><p><strong>如何减少数据拷贝次数？</strong></p><p>在上面那个场景中，我们会历经4次数据拷贝，而因为我们并没有对数据<strong>再加工</strong>，所以数据实际上可以不用搬运到用户空间，因此用户的缓冲区是没有必要存在的。</p><p>这里存在两种<strong>零拷贝技术</strong>:</p><ol><li>mmap + write </li><li>sendfile</li></ol><p><strong>mmap + write</strong><br>read() 系统调用会把内核缓冲区的数据拷贝到用户缓冲区中，于是为了减少这一步开销，我们可以用mmap()替换read()系统调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">wrtie(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p>mmap() 系统调用函数会直接把内核缓冲区里的数据<strong>映射</strong>到用户空i教案，这样操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><strong>具体流程</strong></p><ul><li>应用进程调用了mmap后，DMA会把磁盘的数据拷贝到内核缓冲区里，接着，应用进程跟操作系统内核共享这个缓冲区</li><li>应用进程再调用write(), 操作系统直接将内核缓冲区的数据拷贝到socket缓冲区中，这一切都发生在内核态，由CPU来搬运书</li><li>最后，把内核的socket缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由DMA搬运的</li></ul><p>sendfile可以替换前面的read和write两个系统调用，这样可以减少一次系统调用，减少了2次上下文切换的开销</p><p>真正的<strong>零拷贝</strong>技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有CPU来搬运数据，所以数据都是通过DMA来进行传输的。简单来说就是，网卡控制器可以直接将内核缓冲区的数据拷贝到网卡缓冲区中，减少了一次CPU的拷贝</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS详解</title>
      <link href="/2025/04/29/DFS%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/29/DFS%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS算法详解-LeetCode相关题"><a href="#DFS算法详解-LeetCode相关题" class="headerlink" title="DFS算法详解-LeetCode相关题"></a>DFS算法详解-LeetCode相关题</h2><blockquote><p>首先我们来了解一下基础的DFS算法</p></blockquote><p>DFS：<strong>深度优先搜索</strong>，从字面上我们可以理解，搜索是优先深度的，也就是说一条路走到底再试另一条。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> src)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nex : graph[src]) &#123;</span><br><span class="line">        dfs(nex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这是DFS基本模板 */</span></span><br></pre></td></tr></table></figure><p>DFS一般用来解决以下几种问题:</p><ol><li><strong>连通分量</strong></li><li><strong>判断是否有环</strong></li></ol><p>我们先来看一道DFS的入门题(模板题)</p><hr><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。 –<strong>LeetCode 200</strong></p><p>我们理解几个概念：</p><ul><li>岛屿 –被“0”包围的“1”块</li><li>连通分量 – 对于一个无向图而言，连通块的各个点之间可达，可以理解成一个岛，岛内的人为一个整体，岛与岛之间不相连</li></ul><p>因此这题显然就是让我们求连通分量的个数，这是DFS的最简单应用，下面给出模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !vis[i][j]) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(grid, vis, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">boolean</span>[][] vis, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不在grid范围内</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= m || y &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为海洋无法访问</span></span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已被访问</span></span><br><span class="line">        <span class="keyword">if</span> (vis[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">            dfs(grid, vis, x + dir[<span class="number">0</span>], y + dir[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单对吧，这里简单解释一下代码</p><ul><li>dirs: 代表着上下左右的方向</li><li>这里每次访问到一个1时进行DFS自然就将整个连通分量全遍历过(visit)， 因此这样计算出来的就是连通分量的数量</li></ul><p>掌握这个模板之后，我们就可以应付很多基础的DFS题，比如求岛屿的面积、周长等</p><p>图论题中往往还会有另一种形式，像上述的题目已经将图帮我们建完了，因此</p><hr><p>给你一个整数 n 。现有一个包含 n 个顶点的 无向 图，顶点按从 0 到 n - 1 编号。给你一个二维整数数组 edges 其中 edges[i] &#x3D; [ai, bi] 表示顶点 ai 和 bi 之间存在一条 无向 边。</p><p>返回图中 完全连通分量 的数量。</p><p>如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为 连通分量 。</p><p>如果连通分量中每对节点之间都存在一条边，则称其为 完全连通分量 。 – <strong>LeetCode 2685</strong></p><p>这题没有直接给出网格图，因此首先我们需要自己建图，这里介绍一种我喜欢的建图方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">Arrays.setAll(graph, i -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">    graph[x].add(y);</span><br><span class="line">    graph[y].add(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 该是双向图的建图法，单向图需要注意边的方向*/</span></span><br></pre></td></tr></table></figure><p>下面给出该题的解题思路和解法：<br>题目已经说明完全连通分量的概念，这里存在一个公式 e &#x3D; v * (v - 1) &#x2F; 2; 这是很显然的因为每个点之间都存在一条边,因此我们只需要通过dfs遍历得到连通分量判断是否是完全连通分量即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countCompleteComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edge)</span> &#123;</span><br><span class="line">        <span class="comment">// 套建图模板</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        Arrays.setAll(graph, i -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            graph[x].add(y);</span><br><span class="line">            graph[y].add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">            dfs(graph, i, vis);</span><br><span class="line">            <span class="keyword">if</span> (e == v * (v - <span class="number">1</span>)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边</span></span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="comment">// 点</span></span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> cur, <span class="type">boolean</span>[] vis)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[cur]) &#123;</span><br><span class="line">            <span class="keyword">return</span>；</span><br><span class="line">        &#125;</span><br><span class="line">        vis[cur] = <span class="literal">true</span>;</span><br><span class="line">        v++;</span><br><span class="line">        e += graph[cur].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nex : graph[cur]) &#123;</span><br><span class="line">            dfs(graph, nex, vis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 值得注意的是其实在我们的dfs函数中，每条边被算了两次*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来再介绍两种用DFS判环的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Method 1*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> cur, <span class="type">boolean</span>[] vis, <span class="type">boolean</span>[] path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path[cur]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis[cur]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    vis[cur] = <span class="literal">true</span>;</span><br><span class="line">    path[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nex : graph[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(graph, nex, vis, path)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path[cur] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*Method 2*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> cur, <span class="type">int</span> fa, <span class="type">boolean</span>[] vis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[cur]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nex : graph[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nex == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(graph, nex, cur, vis))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Method 3*/</span></span><br><span class="line"><span class="comment">/*三色标记法*/</span></span><br><span class="line"><span class="comment">/*0 代表未访问 1代表正在访问 2代表已访问*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; graph, <span class="type">int</span> cur, <span class="type">int</span>[] color)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (color[cur] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (color[cur] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    color[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nex : graph[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(graph, cur, color)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[cur] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路就是DFS不能访问到仍在递归栈的数，比如1 -&gt; 2 -&gt; 3 -&gt; 1, 这条DFS路线，当1往下递归时又遇到了自己这代表形成了环</p><hr><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p><p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。 – *<strong>LeetCode 207</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line">    Arrays.setAll(graph, i -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        graph[x].add(y);</span><br><span class="line">        <span class="comment">/* 单向图 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] color = <span class="keyword">new</span> <span class="title class_">int</span>[numCoureses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCoureses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, i, color)) &#123;</span><br><span class="line">            <span class="comment">/* 存在环不能完成课程 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> cur, <span class="type">int</span>[] color)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (color[cur] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (color[cur] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    color[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nex : graph[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(graph, nex, color)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="/2025/04/26/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2025/04/26/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>单片机的CPU是直接操作物理内存的，因此想要同时运行两个程序是做不到的，因为如果第一个程序在地址x的位置写入数据，第二个程序同样需要用到地址x，则会发生冲突。</p><p>因此我们需要用到虚拟地址来分割不同进程之间的内存地址，即给每个进程分配一个虚拟地址，虚拟地址与物理地址之间的映射关系对于进程而言是透明的，进程只需要直接对虚拟地址操作即可。<br>操作系统提供了一种机制，将虚拟地址和物理地址联系起来。</p><blockquote><p>虚拟地址：程序使用的内存地址<br>物理地址：硬件实际的内存空间</p></blockquote><hr><blockquote><p>我们上文提到了操作系统将虚拟地址和物理地址映射的机制，接下来我们将介绍这种机制</p></blockquote><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由多个逻辑段构成：</p><ul><li>代码段</li><li>数据段</li><li>堆段</li><li>栈段<br>因此我们可以通过内存分段的形式进行虚拟地址与物理地址的映射</li></ul><p>在内存分段的情况下<br>虚拟地址 &#x3D; 段选择因子 + 段偏移量<br>段偏移量我们很好理解就是内存段中的offset，当我们访问一块内存区域时，需要知道该内存在段中的哪个部分<br>段选择因子中包括了段号，通过段号我们可以在段表上找到对应的段描述符，段描述符中包括了段基址和段界限还有特权级<br>段界限用来判断访问的段地址是否合法，如果地址合法那么访问的地址就是段基址 + 段偏移量</p><p><strong>缺陷</strong></p><ol><li>内存碎片问题<br>在分段的情况下，容易产生内存外碎片，导致大内存程序即使在剩余内存空间够的情况下，但是由于内存分散导致无法载入，因此继而产生了接下来的内存交换问题</li><li>内存交换问题<br>解决内存碎片问题的一个方式就是内存交换，但内存碎片多的时候将已载入内存的部分放入硬盘重新载入（swap），使得与其他段紧挨着，减少碎片，以此解决内存碎片问题，但是频繁的内存交换导致性能瓶颈。</li></ol><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>内存分页就是在上述情况下出现<br>内存分页就是将虚拟内存和物理内存划分成大小一致的页，在Linux中为4KB</p><p>虚拟地址和物理地址通过页表进行地址映射。内存管理单元MMU负责将虚拟地址转化为物理地址。当进程访问的虚拟地址在页表上查询不到时会产生一个缺页中断，然后进入系统内核空间分配物理内存，更新进程页表，最后返回用户空间。<br>虚拟地址分为页号 + 偏移量两个部分，页表中存储了虚拟页号和物理页号的映射关系，找到对应的物理页号后根据偏移量找到实际的地址</p><p><strong>分页是如何解决内存碎片问题?</strong><br>因为分页将内存划分成大小相同的页，因此程序只需要取数量的页即可，但是这里存在内存内碎片问题，因为页的大小是相同的，因此页内存在碎片问题</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>多级页表是为了解决简单分页下出现的内存占用问题<br><strong>简单分页</strong><br>在简单分页下，我们知道在32位系统下，虚拟内存有4G，一个页的大小是4KB，因此分成2的20次方个页，每个页表项需要4B大小存储，因此这里总共是4MB，对于每个进程而言都有一个页表，因此产生的开销是巨大的，在这种情况下我们考虑采用多级页表的形式</p><p>事实上，我们考虑一下复杂分页并不能减少内存的时候，比如对于2的20次方个页，我们分成二级页表而言需要4KB(1024)大小的一级页表，以及4MB(1024 * 1024)大小的二级页表，这样一想并没有减少内存的使用呀？但实际上这里涉及了<strong>懒惰分配</strong>的原则，由于程序具有局部性原理，对于没有用到的地址我们展示不分配二级页表因此减少了内存的使用</p><blockquote><p>对于64位系统而言页表一般是四级：</p><ul><li>全局页</li><li>上层页</li><li>中间页</li><li>页表项</li></ul></blockquote><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>但是由于页表结构变得复杂，那么虚拟地址的转化也会变得复杂，因此出现了TLB，即一种缓存结构，放置了最常访问的页表项和对应的物理页，CPU在寻址时首先会查询TLB，然后进行地址转换<br>通常情况下TLB的命中率比较高，因为程序具有局部性原理</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>what is rag?</title>
      <link href="/2025/04/26/what-is-rag/"/>
      <url>/2025/04/26/what-is-rag/</url>
      
        <content type="html"><![CDATA[<h2 id="Rag"><a href="#Rag" class="headerlink" title="Rag"></a>Rag</h2><blockquote><p>Rag:Retrieval Augmented Generation</p></blockquote><h3 id="什么是RAG？"><a href="#什么是RAG？" class="headerlink" title="什么是RAG？"></a>什么是RAG？</h3><p>假如你是一位导游, 但是对景点并不熟悉，你通过查询资料来完成导游工作，此时你更像是一个知识的总结者。同样的，给大模型配置知识库，让它参考查询到的信息回答原本无法回答的问题，这种结合了传统的信息检索与文本生成的方法就是检索增强生成</p><p>这里存在两种知识库形式</p><ol><li>统一配置的知识库，比如像常见的阿里云官网的agent，它配置了相关产品的知识库，因此提问时可以做出相应的回答</li><li>支持用户上传个性化资料，来满足个性化业务的需求，也就是允许用户搭建私域知识库<br>这两种方式都是通过知识库来增强大模型能力，减少”幻觉”回答的情况</li></ol><p>RAG包括三个步骤：</p><ul><li>索引，建立知识库的过程就是给知识索引</li><li>检索，大模型根据问题检索知识库</li><li>生成，根据检索到的资料进行思考生成结果<br>具体来说:</li></ul><ol><li><p>建立索引。清洗和提取原始数据，将PDF、Docx等不同格式的文件解析为纯文本数据，然后将文本数据分割成更小的chunk，进入嵌入模型转化为向量数据(embedding),以便后续检索</p></li><li><p>检索生成。系统会获取到用户输入，随后计算出用户的问题与向量数据库中的文档快的相似度，选择相似度最高的K个文档块作为回答当前问题的知识。知识与问题会合并到提示词模板中提交给大模型，大模型给出回复，这就是检索生成的过程</p><blockquote><p>提示词模板: 请阅读:{knowledge}, 请问:{question}</p></blockquote></li></ol><h3 id="增强RAG能力"><a href="#增强RAG能力" class="headerlink" title="增强RAG能力"></a>增强RAG能力</h3><ol><li>提高索引准确率</li></ol><ul><li>优化文本解析</li><li>优化chunk切分</li><li>句子滑动窗口检索</li><li>自动合并检索</li></ul><ol><li>让问题更好理解</li></ol><ul><li>Enrich完善用户问题</li></ul><ol><li>改造信息抽取途径</li></ol><ul><li>互联网搜索</li></ul><ol><li>回答前反复思考</li></ol><ul><li>Self-RAG</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rag </tag>
            
            <tag> llm </tag>
            
            <tag> agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-服务端</title>
      <link href="/2025/04/26/redis-%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>/2025/04/26/redis-%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><blockquote><p>本章将分为三个部分:1. 服务器处理命令的过程 2. severCron函数 3. 服务器的启动过程</p></blockquote><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><blockquote><p>以set key value为例</p></blockquote><ol><li>客户端向服务端发送命令请求SET KEY VALUE</li><li>服务端接收并处理客户端发来的命令请求SET KEY VALUE， 在数据库中进行设置并产生命令回复OK</li><li>服务器将命令回复返回给客户端</li><li>客户端接收服务器返回的命令回复OK，并将命令回复打印给用户观看</li></ol><h4 id="1-发送命令请求"><a href="#1-发送命令请求" class="headerlink" title="1. 发送命令请求"></a>1. 发送命令请求</h4><p>Redis服务器的请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转化为协议格式，发送给服务器</p><h4 id="2-读取命令请求"><a href="#2-读取命令请求" class="headerlink" title="2. 读取命令请求"></a>2. 读取命令请求</h4><p>当客户端与服务端之间的连接套接字因为客户端的写入而可读时，服务器将调用命令请求处理器来执行以下操作</p><ol><li>读取套接字中协议格式的命令请求，将其保存到客户端状态的输入缓冲区</li><li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数和命令参数的格式保存到客户端状态中，可以在客户端那一节看到</li><li>调用命令执行器，执行客户端指定的命令</li></ol><h4 id="3-命令执行器"><a href="#3-命令执行器" class="headerlink" title="3. 命令执行器"></a>3. 命令执行器</h4><ol><li>查找命令的实现<br>命令执行器第一件事就是根据客户端状态中命令参数的第一个参数，即“SET”的命令操作，在命令表(<strong>commandtable</strong>)中查找参数对应的命令</li></ol><p>命令表：一个字典，键为命令名字符串，值为rediscommand结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct redisCommand &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    /* 函数指针，指向命令的实现函数*/</span><br><span class="line">    redisCommandProc *pro;</span><br><span class="line">    /* 标志位 */</span><br><span class="line">    char *sflags;</span><br><span class="line">    long long calss;</span><br><span class="line">    long long millisecondes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标志位包括: ‘r’ 只读命令， ‘w’写入命令等等给</p><ol><li>执行预备操作<br>在执行命令前，还有一些操作：</li></ol><ul><li>判断是否能找到对应命令</li><li>判断命令参数个数</li><li>身份验证是否通过</li><li>…<br>这里不过赘述</li></ul><ol><li>命令执行<br>在前面我们已经得到了执行该命令的参数，该命令的实现函数，进行调用即可</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client -&gt; cmd -&gt; proc(client);</span><br></pre></td></tr></table></figure><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复都会被保存在客户端状态的输出缓冲区中。</p><ol><li><p>命令执行后续操作</p><blockquote><p>做一些收尾工作</p></blockquote></li></ol><ul><li>如果服务器开启了慢查询日志功能，检查是否需要添加慢查询记录</li><li>更新命令执行所需要的时间</li><li>AOF持久化功能，追加写入AOF</li><li>主从架构中，将该命令传播给其他从服务器</li></ul><h4 id="4-将命令回复发送给客户端"><a href="#4-将命令回复发送给客户端" class="headerlink" title="4. 将命令回复发送给客户端"></a>4. 将命令回复发送给客户端</h4><p>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器, 当客户端的套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区的中命令回复发送给客户端</p><h4 id="5-客户端接收并打印命令回复"><a href="#5-客户端接收并打印命令回复" class="headerlink" title="5. 客户端接收并打印命令回复"></a>5. 客户端接收并打印命令回复</h4><p>客户端接收命令打印命令回复</p><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><blockquote><p>serverCron函数默认每隔100ms执行一次，这个函数负责管理服务器资源，并保持服务器的良好运行</p></blockquote><h4 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h4><p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的次数，对于一些对时间精度要求不是很高的场景使用时间的缓存</p><ul><li>对于打印日志、更新服务器LRU时钟等等对时间精度要求不是很高的情况下采用缓存时间</li><li>对于为键设置过期时间，添加慢查询日志这种需要高精度时间的功能来说，服务器会再次执行系统调用而不是当前时间</li></ul><h4 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h4><p>简单来说就是，因为LRU策略需要记录键被访问的时间，如果采用系统调用的方式获取时间，那么开销比较大，这里记录了系统的LRU时钟，每100ms更新，在这100ms的周期中，所有键被访问都是使用当前系统的LRU时钟</p><h4 id="更新服务器中每秒执行命令的次数"><a href="#更新服务器中每秒执行命令的次数" class="headerlink" title="更新服务器中每秒执行命令的次数"></a>更新服务器中每秒执行命令的次数</h4><h4 id="更新服务器内存峰值的记录"><a href="#更新服务器内存峰值的记录" class="headerlink" title="更新服务器内存峰值的记录"></a>更新服务器内存峰值的记录</h4><h4 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h4><p>Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识，当每次serverCron函数运行时，都会检查这个标识，决定是否关闭服务器(在关闭服务器前会执行RDB持久化操作)</p><h4 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h4><p>调用clientCron函数，如果客户端连接超时则释放，如果输入缓冲区大小超过长度释放当前客户端输入缓冲区，重新创建一个默认大小的输入缓冲区</p><h4 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h4><p>调用databaseCron函数，检查过期键等</p><h4 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h4><p>如果没有在执行任务持久化操作：</p><ol><li>BGREWRITEAOF被延迟？执行BGREWRITEAOF</li><li>自动保存条件是否满足？执行BGSAVE</li><li>AOF重写条件是否满足？执行BGREWRITEAOF</li></ol><h4 id="将AOF缓冲区内容写入AOF文件"><a href="#将AOF缓冲区内容写入AOF文件" class="headerlink" title="将AOF缓冲区内容写入AOF文件"></a>将AOF缓冲区内容写入AOF文件</h4><h4 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h4><h4 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h4><blockquote><p>可能在某些serverCron执行了几次后执行的函数中使用</p></blockquote><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><blockquote><p>初始化服务器状态、接收用户指定服务器配置、创建对应的数据结构和网络连接等</p></blockquote><h4 id="1-初始化服务器状态默认状态"><a href="#1-初始化服务器状态默认状态" class="headerlink" title="1. 初始化服务器状态默认状态"></a>1. 初始化服务器状态默认状态</h4><p>创建一个redisServer的结构体并且赋值默认值，调用initServerConfig函数</p><h4 id="2-载入配置项"><a href="#2-载入配置项" class="headerlink" title="2. 载入配置项"></a>2. 载入配置项</h4><p>在调用initServerConfig函数初始化server变量后哦，就会开始载入用户给定的配置参数和配置文件，并根据用户设定的配置，对server变量相关属性的值进行修改</p><h4 id="3-初始化服务器数据结构"><a href="#3-初始化服务器数据结构" class="headerlink" title="3. 初始化服务器数据结构"></a>3. 初始化服务器数据结构</h4><ul><li>clients链表</li><li>db数组<br>调用initServer函数对这些数据结构初始化，同时创建了一些常量，比如回复的“OK”等等给，打开服务器的监听窗口等</li></ul><h4 id="4-还原数据库状态"><a href="#4-还原数据库状态" class="headerlink" title="4. 还原数据库状态"></a>4. 还原数据库状态</h4><p>服务器载入RDB文件或者AOF文件吗，根据文件记录的内容来还原服务器的数据库状态。如果有AOF优先AOF，否则RDB文件</p><h4 id="5-开始执行事件循环"><a href="#5-开始执行事件循环" class="headerlink" title="5. 开始执行事件循环"></a>5. 开始执行事件循环</h4><p>接收连接请求，执行命令</p>]]></content>
      
      
      <categories>
          
          <category> redis的设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simpledb-lab3</title>
      <link href="/2025/04/26/simpledb-lab3/"/>
      <url>/2025/04/26/simpledb-lab3/</url>
      
        <content type="html"><![CDATA[<h2 id="2022秋MIT6-830lab3实验报告"><a href="#2022秋MIT6-830lab3实验报告" class="headerlink" title="2022秋MIT6.830lab3实验报告"></a>2022秋MIT6.830lab3实验报告</h2><blockquote><p>本实验主要实现查询优化器，针对连接优化</p></blockquote><p>连接优化：对于r1 join r2 join r3这样的查询存在很多种不同连接顺序的查询计划，本实验主要针对该连接计划，选择出成本最小的连接计划</p><h3 id="EXERCISE-1"><a href="#EXERCISE-1" class="headerlink" title="EXERCISE 1"></a>EXERCISE 1</h3><blockquote><p>实现IntHistogram</p></blockquote><p>IntHistogram是针对int字段的直方图，通过直方图我们可以得到一个谓词在一个字段上的选择性，即经过这个谓词过滤出多少比例元组, 该类没有什么难点，根据hint编写计算逻辑即可，核心逻辑展示：<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/1781c69726b052de4d833000d6671e8.png" alt="estimate"></p><h3 id="EXERCISE-2"><a href="#EXERCISE-2" class="headerlink" title="EXERCISE 2"></a>EXERCISE 2</h3><blockquote><p>实现TableStats</p></blockquote><p>这里TableStats是记录表的数据，主要是包括各个Field的直方图，同样比较简单，这里给出具体的实现逻辑<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/9ee9f65136285bc80bb8e61a027ef7e.png" alt="TableStats"></p><p>需要两次遍历，第一次维护int的max和min数组，第二次进行addValue操作</p><h3 id="EXERCISE-3"><a href="#EXERCISE-3" class="headerlink" title="EXERCISE 3"></a>EXERCISE 3</h3><blockquote><p>实现两个估算成本的方法</p></blockquote><p><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/55f9b39589e7eadd1b7a8e33d08baaf.png" alt="estimate"><br>该方法根据hint中的公式填写即可</p><p><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/989e645fdc16233e6a348a8ddefba5b.png" alt="estimate"><br>根据公式计算即可:</p><ol><li>如果有key，则不超过key的tuple数</li><li>如果是笛卡尔积，乘0.3的经验系数，同时必须大于两个表的任意一个card</li></ol><h3 id="EXERCISE-4"><a href="#EXERCISE-4" class="headerlink" title="EXERCISE 4"></a>EXERCISE 4</h3><blockquote><p>实现orderJoins</p></blockquote><p>这里采用塞林格优化的方法，其实本质上是动态规划，从小集合推导到大集合的最优方法<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/ad7f59a56045e8bb567e2970c7621b1.png" alt="orderJoins"></p><ul><li>planCache，类似记忆化，记录之前的最优方法</li><li>costcard，将plan cost card聚合成一个类</li><li>computeCostAndCardOfSubPlan, 本质是上计算+与当前最优值比较，如果目前方法更优则返回plan否则是null</li></ul><p>这里仔细研究一下computeCostAndCardOfSubPlan的源码</p><p>核心代码：<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/d40e7ac65f741c7110448069640a602.png" alt="core"></p><p>news是去掉joinToRemove的集合，如果空代表着是基础连接，即 r1 join r2, 这里只需要分别计算cost 和 card即可，否则则是子连接 和 一个表的连接，具体来看doesJoin函数检查哪个是已join的连接计划中的，如果是已join的连接计划的表，可以通过，planCache得到对应的cost和card，这样最终得到了两个表的cost和card，通过上述实现的estimateJoinCost函数计算连接成本与bestCost比较从而得到最后的costcard</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>simpledb-lab2</title>
      <link href="/2025/04/26/simpledb-lab2/"/>
      <url>/2025/04/26/simpledb-lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="2022秋MIT6-830lab2实验报告"><a href="#2022秋MIT6-830lab2实验报告" class="headerlink" title="2022秋MIT6.830lab2实验报告"></a>2022秋MIT6.830lab2实验报告</h2><h3 id="EXERCISE-1"><a href="#EXERCISE-1" class="headerlink" title="EXERCISE 1"></a>EXERCISE 1</h3><blockquote><p>实现Filter、Join两个操作符</p></blockquote><p>首先我们需要关注Predicate这个类，字面意思上理解，Predicate就是谓词，具体在lab中用来判断tuple的第field个field的val是否op这个operand</p><p>那么Predicate类我们可以很easy的实现，主要需要实现的是filter函数，这里调用field的compare方法即可</p><p>同理JoinPredicate类我们也可以很easy的实现，这里JoinPredicate与Predicate不同之处就是JoinPredicate是用于两个tuple之间而不是一个tuple一个operand。同样也是调用field的compare方法</p><p>接下来我们需要实现Filter, 这是我们最终要实现的操作符，简单来说Filter起到一个where的作用，即过滤语句</p><blockquote><p>这里可以看看已经为我们实现好的GroupBy，这也是一个Operator，参考它的写法</p></blockquote><p>Filter内需要一个Predicate，谓词，同时还需要一个child的OpIterator，需要通过OpIterator来遍历tuple来执行谓词操作<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/aae6bdbbb65f1ae79090a80a22ac42c.png" alt="fetchNext"><br>核心函数实现，其他方法根据doc编写即可，这里需要注意的是open和close都需要调用super方法因为，父类有一个标志位需要开关</p><p>Join同理，这里Join的方法考虑嵌套遍历，遍历第一张表然后遍历第二张表<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/1d26bf04ced3411a19c26ec18edc097.png" alt="fetchNext"></p><blockquote><p>这里可以考虑Join的优化</p></blockquote><h3 id="EXERCISE-2"><a href="#EXERCISE-2" class="headerlink" title="EXERCISE 2"></a>EXERCISE 2</h3><blockquote><p>练习2要求实现的是聚合操作，包括sum，count等，因为String类型的简单只需要count，这里详细介绍int类型的</p></blockquote><p>我将操作抽象出了一个util，包含了operate和getTupleDesc<br>想要记录分组的结果，必然需要通过一个Hash容器，并且这里创建了一个空Field，目的是没有groupBy的col时有一个key<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/cda65c7c76d68022f6de7dd6cc63ba4.png" alt="avg"><br>这里介绍较为复杂的一个op实现，这里的value是int数组，一共有三个元素 0是值 1是总值 2是个数 通过维护这个数组可以得到结果，这里我debug了很久，刚开始只考虑了0，1维护平均值和个数，但是在除的过程中会有精度缺失导致存在偏差</p><h3 id="EXERCISE-3"><a href="#EXERCISE-3" class="headerlink" title="EXERCISE 3"></a>EXERCISE 3</h3><blockquote><p>练习3要求实现HeapPage、HeapFile、BufferPool的delete和insert tuple</p></blockquote><p>HeapPage中insert or delete Tuple直接进行操作即可，但是需要注意header和tuple数组的修改</p><p>HeapFile delete一个tuple首先需要通过BufferPool getPage的方式，获取到对应的HeapPage，然后调用HeapPage的对应方法，<br>需要注意的是如果是insert时没有空的page了，需要新创建一个page然后插入<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/e9cdbce67130d55127cf5df8d7469e3.png" alt="insertTuple"><br>这里给出我的实现</p><p>BufferPool 这里insert or delete tuple需要调用HeapFile的对应方法，并且对返回的page标记为脏页(意味着已经被修改过了)</p><p>这里我们注意到BufferPool和HeapFile的关系好像还是如互相嵌套一般，因为BufferPool其实是server对下层执行引擎获取到的数据的全局访问点。HeapFile的所有操作都会把页刷到bufferPool中，再进行操作</p><blockquote><p>一些细节，当insert Tuple时要注意recordId的修改，因为这里的tuple可能是从别的表得到然后插入新表的(可以这么理解)，但是delete一定是对应的，否则找不到对应的page</p></blockquote><h3 id="EXERCISE-4"><a href="#EXERCISE-4" class="headerlink" title="EXERCISE 4"></a>EXERCISE 4</h3><blockquote><p>练习4要求我们实现Delete和Insert这两个操作符</p></blockquote><p>练习3的操作是基于Page、File、BufferPool的，对于一个操作符而言(以delete为例)首先就需要OpIterator，通过iterator的遍历进行delete，这里的delete需要调用BufferPool的delete操作</p><p>insert同理，比较简单</p><h3 id="EXERCISE-5"><a href="#EXERCISE-5" class="headerlink" title="EXERCISE 5"></a>EXERCISE 5</h3><blockquote><p>本实验要求实现BufferPool的页面置换算法，这里使用LRU算法秒杀了，比较简单</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> simple-db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit </tag>
            
            <tag> database </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-事件</title>
      <link href="/2025/04/26/redis-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2025/04/26/redis-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote><p>Redis服务器是一个事件驱动程序，服务器需要处理两种事件: 1. 文件事件 2. 事件事件 本文会主要从这两个方面介绍</p></blockquote><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><blockquote><p>Redis基于Reactor模式开发了自己的网络事件处理器，即文件事件处理器</p></blockquote><p>具体来说: 文件事件处理器通过IO多路复用程序来监听多个套接字，并且根据套接字目前执行的任务为套接字关联不同的事件处理器，当被监听的套接字准备好执行相应操作时，与操作相对应的文件事件就会产生，此时文件事件处理器就会调用先前绑定在套接字上对应的事件处理器来处理这些事件。</p><p>简单来说就是以IO多路复用同时监听多个套接字，以单线程的方式运行事件处理器</p><p>从上文的描述我们可以把Redis的文件事件处理器分为四个部分:</p><ul><li>套接字</li><li>IO多路复用程序</li><li>事件分派器</li><li>事件处理器</li></ul><p>文件事件是对套接字操作的抽象，每当套接字准备好相应的操作时，对应的文件事件就会产生，显然可以有多个文件事件并发产生</p><p>IO多路复用程序，redis服务器会同时监听多个套接字，并且向事件分派器传递哪些产生了事件的套接字</p><p>事件分派器，接收IO多路复用程序传递的套接字，这里多个并发产生的事件会以队列的形式逐一执行</p><p>事件处理器，处理对应的事件</p><h4 id="IO多路复用程序"><a href="#IO多路复用程序" class="headerlink" title="IO多路复用程序"></a>IO多路复用程序</h4><p>常见的IO多路复用有SELECT、POLL、EPOLL，redis封装了底层的细节，会自动选取效果最佳的方法</p><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><ul><li>可读，当客户端执行write或者connect操作时，套接字会变得可读，产生可读事件</li><li>可写，当客户端执行read操作时，会产生可写事件</li></ul><p>当一个套接字又可读又可写时，服务器先读套接字，后写套接字</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>aeCreateFileEvent: 函数接收一个套接字描述符，一个事件类型，以及一个事件处理器作为参数，将给定的套接字的给定事件加入IO多路复用程序的监听范围之内，并且把该事件与事件处理器相连。</li><li>aeDeleteFileEvenet：删除操作</li><li>aeGetFileEvents: 接收一个套接字，返回该套接字正在被监听的事件类型[AE_NONE AEREADABLE AE_WRITABLE AE_READABLE]</li><li>aewait 接收一个套接字描述符、一个事件类型和一个毫秒数为参数，在指定时间内，得到产生的事件或者超时返回</li><li>aeApiPoll： 阻塞等待所有设置为监听状态的套接字产生事件，或者超时返回</li><li>aeProcessEvents： 遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件</li><li>aeGetApiName: 返回IO多路复用底层使用的函数</li></ul><h4 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h4><blockquote><p>Redis编写了多个事件处理器，分别用来处理客户端连接、命令请求、返回响应、主从复制</p></blockquote><ol><li>连接应答处理器<br>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当客户端调用connet函数时，就会产生可读事件，从而处理连接</li><li>命令请求处理器<br>当客户端通过连接应答处理器成功连接到服务端之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务端发送命令请求的时候，套接字就会产生AE_READABLE事件</li><li>命令回复处理器<br>当服务器有命令回复需要传送给客户端时，服务器会将客户端套接字的AE_WRITEABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITEABLE事件，引发命令回复处理器的执行。</li></ol><p>总流程:<br>Redis服务器正在运行，AE_READABLE事件正在处于监听状态之下，而事件所对应的处理器为连接应答处理器，当Redis客户端发起请求时，监听的套接字将会产生可读事件，触发连接应答处理器的执行，创建一个客户端套接字，并将可读事件与命令请求处理器绑定，使得客户端可以向主服务器发送命令请求。当客户端发送了一次命令请求后，引发命令请求处理器执行，并且会将该客户端可写事件与命令回复处理器绑定，执行命令回复操作</p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><blockquote><p>时间事件分为两种：定时事件、周期事件</p></blockquote><p>一个时间时间主要由以下三个属性组成:</p><ul><li>id：服务器为时间创建的全局唯一ID。ID号按从小到大的顺序递增</li><li>when：UNIX时间戳，记录时间事件的到达时间</li><li>timeProc: 时间事件处理器，当时间事件到达时会调用相应的处理器来处理事件</li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>服务器将所有时间事件放在一个无序链表中，每当时间事件执行器运行时，遍历链表找到对应的已到达的时间事件，并调用相应的事件处理器。</p><blockquote><p>这里无序链表并不影响性能，因为通常来说这个链表非常短，近似与指针</p></blockquote><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>这里的方法与文件事件相似，不过多赘述</p><h4 id="servercron函数"><a href="#servercron函数" class="headerlink" title="servercron函数"></a>servercron函数</h4><ul><li>更新服务器中各类统计信息</li><li>清理数据库中的过期键值对</li><li>关闭和清理连接失效的客户端</li><li>尝试进行AOF或RDB持久化</li><li>如果服务器是主服务器，那么对从服务器进行定期同步</li><li>如果处于集群状态，对集群进行定期同步和连接调试</li></ul><h4 id="文件事件和时间事件的调度问题"><a href="#文件事件和时间事件的调度问题" class="headerlink" title="文件事件和时间事件的调度问题"></a>文件事件和时间事件的调度问题</h4><p>简单来说，由于时间事件是定时的、周期性的，文件事件是随机出现的，因此整个事件的处理过程就是等待时间事件到达，期间处理产生的文件事件</p>]]></content>
      
      
      <categories>
          
          <category> redis的设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-rdb</title>
      <link href="/2025/04/26/redis-rdb/"/>
      <url>/2025/04/26/redis-rdb/</url>
      
        <content type="html"><![CDATA[<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><blockquote><p>因为Redis是内存数据库，它将自己的数据库状态存储在内存里面，所以如果不想办法将存储在内存中的数据库状态持久化到磁盘中，会导致数据丢失，这一章介绍redis的rdb持久化</p></blockquote><h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个Redis命令可以生成RDB文件，一个是SAVE, 另一个是BGSAVE命令，区别就在于SAVE命令会阻塞线程，BGSAVE不会，二者的区别就在于BGSAVE调用fork()方法创建一个子进程用于调用SAVE方法。</p><p>Redis没有特别的命令用于加载RDB文件，当服务器启动的时候就会自动检测RDB文件并且载入，值得一提的是，因为我们知道AOF的新鲜度更高，如果开启了AOF，Redis默认采用AOF的方法恢复</p><p><strong>设置自动保存方法</strong><br>比如：<br>SAVE 900 1<br>SAVE 300 10<br>SAVE 60 10000</p><p>SAVE X Y的含义是如果在X秒内发生了Y次操作，则会进行BGSAVE操作</p><p>具体来说Redis服务器中保存了一个字段saveparam *saveparams，这里记录了秒数和修改数，即我们在配置文件里写的X Y 同时服务器中维护了一个dirty计数器和lastsave属性，其实也很好理解，因为我们需要记录dirty即修改次数，以及上一次BGSAVE的时间。</p><p>在服务器内部有一个定时任务serverCron默认100ms就会执行一次，对服务器进行定时的维护，其中一项任务就是检查save选项中的条件是否满足，如果满足则调用BGSAVE命令(这里会遍历上述提到的saveaparams数组), 当执行了SAVE后相应的dirty计数器和lastsave属性需要重新设置</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><blockquote><p>RDB: “REDIS” + db_version + database + EOF(终结符) + check_sum</p></blockquote><p>”REDIS“：类似魔数，用于快速检查载入的文件是否为RDB文件<br>check_sum：就是校验和<br>db_verion: rdb文件版本</p><h4 id="database部分"><a href="#database部分" class="headerlink" title="database部分"></a>database部分</h4><p>我们知道Redis服务器中存有多个数据库，默认情况下为16个，database部分会将所有非空的数据库保存下来</p><p>具体来说这里database的结构还可以细分为:</p><p>SELECTDB db_number key_value_pairs</p><p>SELECTDB为常量，当读入程序遇到这个常量时就知道接下来要读数据库号,key_value_pairs记录的是数据库中所有的键值对</p><p><strong>key_value_pairs</strong><br>分为带过期时间和不带过期时间的pairs，带过期时间的结构为:<br>EXPIRETIME_MS ms TYPE key values<br>这里EXPIRETIME_MS是常量，TYPE也是常量(有不同类型)，例子;<br>EXPIRETIME_MS 1376674000000 REDIS_RDB_TYPE_STRING key values<br>这里的TYPE指的是values的type，分为以下几种:</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REIDS_RDB_TYPE_LIST</li><li>…</li></ul><h4 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a>value的编码</h4>]]></content>
      
      
      <categories>
          
          <category> redis的设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> rdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-aof</title>
      <link href="/2025/04/26/redis-aof/"/>
      <url>/2025/04/26/redis-aof/</url>
      
        <content type="html"><![CDATA[<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><blockquote><p>除了RDB持久化方法外，Redis还提供了AOF持久化功能，两者的区别在于AOF是通过记录写命令来记录数据库状态的</p></blockquote><h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><blockquote><p>AOF持久化功能的实现可以分为APPEND、SYNC、文件写入三个部分</p></blockquote><h4 id="APPEND-命令追加"><a href="#APPEND-命令追加" class="headerlink" title="APPEND 命令追加"></a>APPEND 命令追加</h4><p>当AOF持久化功能开启时，服务端执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区。即在redisServer结构体中存在一个sds的缓冲区字段</p><h4 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h4><p>我们知道Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，当处理完命令请求后，会调用flushAppendOnlyFile的函数，判断是否需要将aof_buf中的内容保存到aof中</p><p>这里aof的写入同步策略分为三种：</p><ul><li>always 即每次执行完写操作后都需要写入并同步到aof文件中</li><li>everysec 指的是，每过一秒进行一次写入并同步</li><li>no 将aof_buf的缓冲区数据写入aof文件，但是不理解同步，而是将同步操作交给操作系统实现</li></ul><blockquote><p>当用户调用write函数时，系统并不会直接将数据写入文件，而是保存在缓冲区，采用一定策略刷新到磁盘中，而提供了fysnc等函数，表示可以直接刷新到磁盘中</p></blockquote><h3 id="AOF-文件的载入与数据还原"><a href="#AOF-文件的载入与数据还原" class="headerlink" title="AOF 文件的载入与数据还原"></a>AOF 文件的载入与数据还原</h3><p>因为AOF文件里面包含了重建数据库状态的所有写命令，所以载入aof文件只需要执行aof中记录的命令即可，具体来说Redis服务器需要创建一个<strong>fake client</strong>（详情可见客户端章节，因为Redis命令必须在客户端上下文中执行，这个伪客户端没有网络连接，只是起到执行命令的效果</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><blockquote><p>AOF文件存在内存大的情况，存在两个方面：1. AOF文件需要记录所有写命令 2. AOF文件是记录resp协议的写命令这里是以文本形式</p></blockquote><p>为了解决上述问题，AOF文件提供了重写的功能</p><p><strong>AOF重写</strong><br>举个例子<br>Redis list 键中 使用了多条RPUSH 命令 加入了元素， 可以采用一条RPUSH命令重写<br>这里AOF文件重写不需要对现有的AOF文件进行任何读取、分析、写入操作，而是分析对应的数据库状态，比如新的AOF文件可以通过SADD 替换 多个 ADD操作，一次达到减小AOF文件体积的效果</p><p><strong>AOF后台重写</strong><br>显然AOF重写，调用这个方法的线程会长时间阻塞，因此，像BGSAVE，一样会fork一个子进程进行重写，但是这里就存在了一个问题，子进程在重写时，父进程仍会接收命令，因此导致了不一致，Redis这里采用了AOF重写缓存区的方式记录，Redis服务器执行完一个写命令之后，会把写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程接收到信号后会执行以下几个步骤:</p><ul><li>将AOF重写缓冲区中的数据写入到新AOF文件中</li><li>将新的AOF文件原子性的替换旧的AOF文件</li></ul><p>以上就是<strong>BAREWRITEAOF</strong>命令的实现</p>]]></content>
      
      
      <categories>
          
          <category> redis的设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> aof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-数据库</title>
      <link href="/2025/04/26/redis-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2025/04/26/redis-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis服务器将所有数据库保存在redisServer结构中的db数组中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库，但是一般默认为16个</p><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><p>每个Redis客户端都可以指定使用的数据库，默认使用0号数据库，使用select 1可以选择1号数据库，以此类推，在服务器内部，存在一个数据结构来记录客户端使用的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisClient [</span><br><span class="line">    redisDb *db;</span><br><span class="line">] redisClient</span><br></pre></td></tr></table></figure><p>该指针指向了redisServer.db数组中的某一个元素</p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由redisDb结构表示，其内部维护了一个dict字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库的键值对是直接对应的，即键空间的键就是字符串对象，键空间的值就是不同的redis对象</p><p>具体来说，set message “hello, world!” 就是在数据库的字典中创建了一个键为message的字符串，值为 “hello, world!”字符串的键值对</p><p>读写键空间时会发生一些维护操作：</p><ul><li>当读取一个键之后，会记录命中、不命中次数</li><li>更新LRU时间</li><li>如果读键时发现这个键已经过期了，则删除</li><li>如果有客户端使用watch命令监视了某个键时，当服务器修改了这个键，会把这个键标记为脏</li><li>服务器每次修改一个键之后，都会对脏键计数器的值增1，这个脏键计数器会触发服务器的持久化和复制操作</li><li>如果服务器开启了数据库通知功能，对键进行修改后，服务器将按配置发送相应的数据库通知</li></ul><h3 id="过期键"><a href="#过期键" class="headerlink" title="过期键"></a>过期键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    dict *expires;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在redisDb中维护了一个过期字典，过期字典指向设置了过期时间的对象，并且包含了一个过期时间</p><p>Redis过期删除策略是<strong>定期删除</strong> + <strong>惰性删除</strong>, 具体来说每个一段时间从过期字典中抽取键来检查是否过期并删除，并且在访问一个键时先检查是否过期进行删除</p><h3 id="AOF-RDB-复制对过期键的处理"><a href="#AOF-RDB-复制对过期键的处理" class="headerlink" title="AOF RDB 复制对过期键的处理"></a>AOF RDB 复制对过期键的处理</h3><ol><li>生成RDB文件<br>在执行SAVE命令或者BGSAVE命令会创建一个新的RDB文件，程序对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件</li><li>载入RDB文件</li></ol><ul><li>如果服务器以主服务器模式运行，在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期的则会被忽略</li><li>如果服务器以从服务器模式运行，在载入RDB文件时无论是否过期都会全部载入，但是从服务器还会进行主从同步, 这里不直接删除还是考虑和主服务器的数据一致性问题</li></ul><ol><li>AOF写入<br>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，AOF文件不会有其他任何的影响，因为在过期时被删除会追加一条命令DEL命令，如果还没有被删除更不会产生影响</li><li>AOF重写<br>在执行AOF重写时，已过期的键不会被保存到重写后的AOF文件</li><li>复制<br>当服务器运行在复制模式下时，从服务器的过期删除动作由主服务器控制，简单来说，但主服务器执行DEL操作时会把该命令发送给从服务器。进一步说，从服务器不控制过期键，即从服务器发生了某一个key已经过期了但是不会执行删除操作，当客户端get时仍会返回，只有接收主服务器的del命令后才会删除，这保证了主从服务器之间的一致性，但是存在数据准确性问题</li></ol><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><blockquote><p>分为键空间通知：某个键被执行了哪些操作，键事件通知：某个命令被哪些键执行了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">subscribe __keyspace@0__:message // 指的是订阅了message的键空间通知</span><br><span class="line"></span><br><span class="line">&quot;message&quot;</span><br><span class="line">&quot;__keyspace@0__:message&quot;</span><br><span class="line">&quot;set&quot; // 指的是对message这个键执行了set操作</span><br><span class="line"></span><br><span class="line">subscrible __keyevenet@0__:del</span><br><span class="line"></span><br><span class="line">&quot;message&quot;</span><br><span class="line">&quot;__keyevent@0__:del&quot;</span><br><span class="line">&quot;key&quot; // 指的是del操作被key执行了</span><br></pre></td></tr></table></figure><p>服务器配置的notify-keyspace-evenets选项决定了服务器所发送通知的类型:</p><ul><li>所有类型的键空间通知和键事件通知：AKE</li><li>所有类型的键空间通知：AK</li><li>所有类型的键事件通知：AE</li><li>只和字符串有关的键空间通知: K$</li><li>之和列表键有关的键事件通知: E1</li></ul><p>发送数据库通知的功能是通过notifyKeyspaceEvent函数实现的<br>void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid)<br>event keys dbid分别是事件的名称 产生事件的键 产生事件的数据库号码</p><p>在前文提到，对键的读写操作有额外的操作比如数据库通知，具体来说以sadd命令为例，<br>saddcommand中有一段代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notifyKeyspaceEvent(REDIS_NOTIFY_SET，“sadd”, c-&gt;argv[1], c-&gt;db-&gt;id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>具体看通知函数的实现，这里简单用语言描述;</p><ul><li>如果给定的通知不是服务器允许发送的通知，则直接返回</li><li>发送键空间通知</li><li>发送键事件通知<br>当然上述发送对应的通知需要判断配置设定</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis的设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-客户端</title>
      <link href="/2025/04/26/redis-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2025/04/26/redis-%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><blockquote><p>Redis服务器是典型的一对多服务器程序</p></blockquote><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redisClient结构，这个结构体中包含了：</p><ul><li>客户端的套接字描述符</li><li>客户端的名字</li><li>客户端的标志位</li><li>客户端使用数据库的指针，以及该数据库的号码</li><li>客户端正在要执行的命令、命令参数、命令参数的格式，以及指向命令实现函数的指针</li><li>客户端的输入缓冲区和输出缓冲区</li><li>客户端的复制状态信息，以及进行复制所需的数据结构</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据机构</li><li>客户端的身份验证标识</li></ul><p>Redis的服务器状态中的clients记录了所有与当前服务器相连的客户端</p><h3 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h3><p>伪客户端处理的命令是来自AOF或LUA脚本</p><h3 id="客户端标志"><a href="#客户端标志" class="headerlink" title="客户端标志"></a>客户端标志</h3><ol><li>REDIS_MASTER 标志表示的是客户端代表的一个主服务器，REDIS_SLAVE标志标识客户端代表的是一个从服务器</li><li>REDIS_LUA_CLIENT代表的是客户端是专门用于处理LUA脚本里面包含的Redis命令的伪客户端</li><li>REDIS_MULTI 标志表示的是客户端正在执行事务</li><li>REDIS_FORCE_AOF 强制服务器将当前执行的命令写入到AOF文件</li><li>REDIS_FORCE_REPL 强制主服务器将当前执行的命令复制给所有从服务器</li></ol><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>客户端发送的命令请求保存到客户端状态的queryBuf属性，服务器对命令请求的内容进行解析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv和argc属性，argv属性是一个数组，保存了命令，比如“set”、“val”、“10”。</p><p>内部维护了一个redisCommand，即指向命令表中命令执行函数的地址</p><p>输出缓冲区：分为两个缓冲区</p><ol><li>固定大小的缓冲区用来保存哪些长度比较小的回复</li><li>可变大小的缓冲区用来保存长度比较大的回复，比如元素很多的列表</li></ol><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>存有一个authenticated属性用于记录客户端通过了身份验证</p><p>如果authenticated的值为0，表示客户端未通过身份验证<br>如果authenticated的值为1，表示客户端通过了身份验证</p>]]></content>
      
      
      <categories>
          
          <category> redis的设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-集群</title>
      <link href="/2025/04/26/redis-%E9%9B%86%E7%BE%A4/"/>
      <url>/2025/04/26/redis-%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><blockquote><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移的功能</p></blockquote><p>Redis集群是一种AP模型，它旨在提供高可用性和分区容错性, 集群内部是通过Gossip协议实现数据一致性的，存在以下几种通信信息</p><ul><li>MEET 加入集群</li><li>PING 心跳检测</li><li>PONG 心跳回应</li><li>FAIL 主观下线</li></ul><h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>Redis服务器在启动时会根据cluster-enabled配置选项确定是否开启集群模式，集群模式主要多了cluseterNode等结构保存集群信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct clusterNode &#123;</span><br><span class="line">    // 创建节点实践</span><br><span class="line">    mstime_t ctime;</span><br><span class="line">    // 节点名字</span><br><span class="line">    char name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    ...</span><br><span class="line">    // 保存连接节点的一些信息</span><br><span class="line">    clusterLink *link;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct clusterLink &#123;</span><br><span class="line"></span><br><span class="line">    // 连接创建实践</span><br><span class="line">    mstime_t ctime;</span><br><span class="line">    // TCP 套接字描述符</span><br><span class="line">    int fd;</span><br><span class="line">    // 输出缓冲区，保存着等待发送给其他节点的信息</span><br><span class="line">    sds sndbuf;</span><br><span class="line">    // 输入缓冲区，保存着从其他节点接收到的信息</span><br><span class="line">    sds rcvbuf;</span><br><span class="line">    // 与这个连接相关的节点</span><br><span class="line">    clusterNode *node;</span><br><span class="line">&#125; clusterLink;</span><br><span class="line"></span><br><span class="line">// 集群状态</span><br><span class="line">typedef struct clusterState &#123;</span><br><span class="line">    clusterNode *myself;</span><br><span class="line">    ...</span><br><span class="line">    // 集群节点名单</span><br><span class="line">    dict *nodes;</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><h4 id="MEET命令实现"><a href="#MEET命令实现" class="headerlink" title="MEET命令实现"></a>MEET命令实现</h4><p>Example.<br>向节点A发送MEET ip port 节点B的信息，此时节点A将与节点B发生握手，来确认彼此的存在</p><ul><li>节点A会为节点B创建一个ClusterNode，并添加到ClusterState字典中</li><li>节点A为节点B发送一条MEET消息，表示接收到MEET命令</li><li>节点B同样为节点A创建一个ClusterNode，并添加到ClusterState中</li><li>节点B返回一条PONG消息，节点A接收到后返回PING消息，此时握手结束</li></ul><p>此后通过GOSSIP协议，节点会逐步知道集群的信息，集群信息达成最终一致性</p><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><h4 id="节点的槽指派信息"><a href="#节点的槽指派信息" class="headerlink" title="节点的槽指派信息"></a>节点的槽指派信息</h4><p>在上文提到的clusterNode中，会存有一个数组记录节点的槽指派信息<br><strong>unsigned char slots[16384 &#x2F; 8]</strong>, 该数组是比特数组，对于第i个槽位是否由本节点计算可以通过以下公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slots[i / 8] &gt;&gt; (i % 8) &amp; 1 == 1?</span><br></pre></td></tr></table></figure><h4 id="集群的槽指派信息"><a href="#集群的槽指派信息" class="headerlink" title="集群的槽指派信息"></a>集群的槽指派信息</h4><p>在上文提到的clusterstate结构体中存有一个字段<br><strong>clusterNode slots[16834]</strong><br>这个用于记录每个槽指派的节点，这个与单节点clusterNode结构体中的slots数组相辅相成，一个用于单节点明确是否负责槽，一个用于明确集群中槽的分配情况</p><p>这些槽位信息是通过前文提到的GOSSIP协议进行传播的，保持集群中信息的一致性</p><blockquote><p>只有当集群中16384个槽都被指派了节点后集群才能进入上线状态</p></blockquote><p>cluster addslots 命令用于槽指派，比如cluster addslots 1 2 就是把槽1，2都指派给对应的节点</p><h3 id="集群中命令的执行"><a href="#集群中命令的执行" class="headerlink" title="集群中命令的执行"></a>集群中命令的执行</h3><p>我们知道集群中数据已经被切片成16384个槽，因此对一个服务端进行get操作时(举个例子)，不一定在该节点上，具体来说需要经过以下几个步骤：</p><ul><li>计算键属于哪个槽这里采用crc16算法</li><li>判断槽是否由自己负责，如果不是则通过clusterState中的slot数组找到对应的节点</li><li>返回 MOVED信息</li><li>客户端接收到MOVED信息后重定向发起命令</li></ul><p>节点还会保存槽与键的关系，通过skipList，因为存在命令cluster getkeysinslot slot count 返回最多count个属于slot的数据库键</p><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><blockquote><p>重新分片是利用redis-trib实现的</p></blockquote><p>这里不强调重新分配的指令，而是梳理重新分配的流程</p><ol><li>开始对槽slot重新分片</li><li>目标节点准备导入槽slot的键值对</li><li>源节点准备迁移槽slot的键值对</li><li>源节点如果保存了槽slot的键，则逐步开始迁移，如果没有则直接把槽指派给目标节点</li><li>完成对槽slot的重新分片</li></ol><p>那这里会存在一个问题，当槽迁移时，客户端发来命令怎么办？继续往下看</p><h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>ASK错误指的就是当槽发生迁移，但是请求达到了节点上，此时就会返回ask错误。这也是gossip协议产生的最终一致性问题，在迁移过程时，槽的分配情况在集群中还未能更新至一致。简单的例子，比如“cat”和“dog”都是要迁移的槽位的键，而“cat”已经完成了迁移，但是“dog”还没有，此时get cat已经打到了该节点上，那么就会返回ask 指向正确的节点</p><p>其实 clusterState中维护了两个数组 importing_slots_from 代表的是从某个节点迁出 migrating_slots_to 代表的是迁入某个节点</p><p>但一般而言，如果客户端向节点发送一个关于槽i的命令，如果节点本身发现没有槽i没有被指派给自己，则会返回错误，而这里需要通过上文提到的importing_slots_from和ASKING命令实现</p><p>当返回ASK错误时，客户端会先向redirect的节点发送ASKING，类似激活开关位，下次访问时如果槽i没有被指派给自己但是，在importing_slots_from这个数组中，并且上述的开关位被激活，则会执行该命令</p><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis集群中的节点分为主节点和从节点，可以划分主从节点形成主从架构，其中主节点用于处理槽，而从节点用于复制某个主节点。</p><p>当一个节点成为其他节点的从节点时，<br>在clusterState中myself即指向自身的clusterNode指针中的slaveof指针指向主节点的clusterNode，同时集群中的其他节点维护主节点clusterNode中slaves属性和numslaves属性</p><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>我们提到Redis集群是以gossip协议的形式进行消息的传播的，集群中的每个节点都会定期地向集群中的其他节点发送PING(心跳检测), 接收到PING的节点需要定期返回PONG消息，否则则会标记位疑似下线。</p><p>集群中的各个节点会通过互相发消息的方式来交换集群中各个节点的状态信息，例如某个节点是疑似下线，还是已下线</p><p>当主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，主节点A会在自己的clusterState.nodes字典中找到C对应的clusterNode添加下线报告，具体的结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct clusterNodeFailReport &#123;</span><br><span class="line">    struct clusterNode *node;</span><br><span class="line">    mstime_t time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点报告为疑似下线，那么这个主节点x将被标记为已下线，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的都会把这个节点标记为已下线</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>这里的故障转移和sentinel下的故障转移类似，这里重新梳理一遍</p><ol><li>集群维护一个变量配置纪元，即termId</li><li>当发生一次故障转移时，termId++</li><li>对于每个配置纪元，每个主节点都有一次投票的机会，这里投票的原则是先到先得</li><li>当从节点发送主节点已下线，向集群广播，要求投票的消息</li><li>主节点拥有投票权，以先到先得的方式投票</li><li>从节点如果收到了半数以上的票数则变为主节点</li><li>若平票，则再次选举</li></ol><p>选举出的新主节点会执行以下流程：</p><ol><li>执行slave of no one 变为主节点</li><li>撤销已下线主节点对槽的指派，并由自己负责</li><li>发送PONG命令，传递信息，让集群知道已经发生了故障转移</li><li>新主节点接收并处理客户端命令</li></ol><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>我们之前一直提到redis集群是通过gossip协议实现一致性的，具体来说存在五种Gossip消息：</p><ul><li>MEET消息：用于加入节点</li><li>PING消息： 集群中的每个节点默认每个一秒钟就会从已知接待你列表中随机选出五个节点，然后对这五个节点中最长没有发送过ping消息的节点发送ping消息，以此检测被选中节点是否在线，除此之外，如果节点A最后一次收到节点B发送PONG消息的时间超过设置的一半，也会发送PING，防止消息更新滞后</li><li>PONG消息：回应PING或MEET消息，或者广播PONG消息立即刷新关于这个节点的认识，比如故障转移操作成功执行后</li><li>FAIL消息：传播节点下线消息</li><li>PUBLISH: 当一个节点收到PUBLISH消息时，节点会执行该命令，并广播(因为不同客户端可能在不同节点订阅了相同的频道)</li></ul><h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    // 消息的长度</span><br><span class="line">    uint32_t tolen;</span><br><span class="line"></span><br><span class="line">    // 消息的类型</span><br><span class="line">    uint16_t type;</span><br><span class="line"></span><br><span class="line">    // 消息正文包含的节点数，只有部分消息使用</span><br><span class="line">    uint16_t count;</span><br><span class="line"></span><br><span class="line">    // 发送者所处的配置纪元</span><br><span class="line">    uint64_t configEpoch;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    // 集群状态</span><br><span class="line">    unsigned char state;</span><br><span class="line"></span><br><span class="line">    // 消息的正文</span><br><span class="line">    union chlusterMsgData data;</span><br><span class="line">&#125; clusterMsg;</span><br><span class="line"></span><br><span class="line">union clusterMsgData &#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        clusterMsgDataGossip gossip[1];</span><br><span class="line">    &#125; ping;</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">        clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">        clusterMsgDataPublish msg;</span><br><span class="line">    &#125; publish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PING消息实现"><a href="#PING消息实现" class="headerlink" title="PING消息实现"></a>PING消息实现</h4><p>当每次发送PING消息时，发送者都从自己的已知节点列表中随机选出两个节点，并发送这两个节点的信息。</p><ul><li>如果被选中节点不存在与接收者的已知节点中，两者之间进行握手</li><li>如果选中节点存在于，则进行更新</li></ul><p>MEET、PONG消息同理</p><h4 id="FAIL消息实现"><a href="#FAIL消息实现" class="headerlink" title="FAIL消息实现"></a>FAIL消息实现</h4><p>FAIL消息中就记录了下线的节点名，其他节点接收到了该消息后把节点标记为下线</p><h4 id="PUBLISH消息的实现"><a href="#PUBLISH消息的实现" class="headerlink" title="PUBLISH消息的实现"></a>PUBLISH消息的实现</h4><p>PUBLISH channel messsage 当一个节点收到这个消息时会集群广播消息，具体原因在上文解释过了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint32_t channel_len;</span><br><span class="line">    uint32_t message_len;</span><br><span class="line">    // 前两个字段记录长度，即记录在bulk_data的消息位置</span><br><span class="line">    unsigned char bulk_data[8];</span><br><span class="line">&#125; clusterMsgDataPublish;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis的设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-sentinel</title>
      <link href="/2025/04/26/redis-sentinel/"/>
      <url>/2025/04/26/redis-sentinel/</url>
      
        <content type="html"><![CDATA[<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><blockquote><p>Sentinel 是 Redis高可用性的保障：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及这些主服务器属下的所有从服务器，并在被监视的主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p></blockquote><h3 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/your/sentinel.conf</span><br></pre></td></tr></table></figure><p>当一个Sentinel启动时，它需要执行以下步骤：</p><ol><li>初始化服务器</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码</li><li>初始化Sentinel状态</li><li>根据给定的配置文件，初始化Sentinel的监视主服务器列表(从服务器后文会提到)</li><li>创建连向主服务器的网络连接</li></ol><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><blockquote><p>sentinel本质上是一个Redis服务器</p></blockquote><p>但是Sentinel执行的工作和普通的Redis节点而言不太一样，因此在初始化时不会像普通的服务器载入RDB文件或AOF文件来还原数据库状态。</p><h4 id="替换Sentinel的专用代码"><a href="#替换Sentinel的专用代码" class="headerlink" title="替换Sentinel的专用代码"></a>替换Sentinel的专用代码</h4><p>Sentinel的会将普通Redis服务器使用的代码进行专用代码替换，Sentinel会采用专门的Sentinelcmds作为服务器的命令表，因此在Sentinel模式下，一些SET等命令无法使用</p><h4 id="初始化Sentinel状态"><a href="#初始化Sentinel状态" class="headerlink" title="初始化Sentinel状态"></a>初始化Sentinel状态</h4><p>服务器的一般状态由redisServer结构保存，Sentinel服务器由sentinelState结构保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct sentinelState &#123;</span><br><span class="line">    /*</span><br><span class="line">      核心字段，保存了所有被这个sentinel监视的主服务器</span><br><span class="line">      字典的键时主服务器的名字</span><br><span class="line">      字典的值则是一个指向sentinelRedisInstance结构的指针</span><br><span class="line">    */</span><br><span class="line">    dict *masters;</span><br><span class="line"></span><br><span class="line">    int tilt;</span><br><span class="line">    mstime_t tilt_start_time;</span><br><span class="line">    list *scripts_queue</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化Sentinel状态的masters属性"><a href="#初始化Sentinel状态的masters属性" class="headerlink" title="初始化Sentinel状态的masters属性"></a>初始化Sentinel状态的masters属性</h4><p>在上文，我们提到了一个dict结构，保存了主服务器名和对应的主服务器信息，这里介绍以下sentinel中主服务器的info结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct sentinelRedisInstance &#123;</span><br><span class="line">    // 标识位</span><br><span class="line">    int flag;</span><br><span class="line"></span><br><span class="line">    // 实例的名字</span><br><span class="line">    // 主服务器的名字由用户在配置文件中设置</span><br><span class="line">    // 从服务器以及Sentinel的名字由Sentinel自动设置 ip:port</span><br><span class="line">    char *name;</span><br><span class="line">    ...</span><br><span class="line">    // 自定义结构体&#123;ip, port&#125;</span><br><span class="line">    sentinelAddr* addr;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure><blockquote><p>这里注意sentinelRedisInstance是保存主服务器和从服务器的实例信息，但是sentinel初始化时只会连接主服务器，<a href="#point-1">这里存有疑点，后面会有解答。</a></p></blockquote><h4 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h4><p>Sentinel会创建两个连向主服务器的异步网络连接：</p><ul><li>命令连接，这个连接用于向主服务器发送命令，并接收命令回复</li><li>订阅连接，订阅主服务器的_sentinel_:hello频道</li></ul><p>简单来说sentinel通过命令连接向服务器的频道发送信息，又从订阅连接，通过订阅频道接收信息，目前可以简单理解成：多个sentinel可以通过频道发布信息，使得订阅该频道的sentinel同时接收，注意到我们配置sentinel时是没有确定其他sentinel信息的，通过这种方式可以建立sentinel集群之间的通信。后文还有更加具体的用法。</p><h3 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h3><p>Sentinel默认会以每秒十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，主服务器会返回一些信息包括了主服务器自身的信息，还有主服务器属下所有从服务器的信息，因此sentinel无须用户提供从服务器的地址信息， 就可以自动发现这些从服务器。</p><h3 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h3><p>当sentinel发现主服务器有新的从服务器出现时，sentinel除了会为这个新的从服务器创建从服务器得命令连接和订阅连接，和主服务器基本一致</p><h3 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h3><p>在默认情况下,sentinel 会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH _sentinel_:hello xxx xxx</span><br></pre></td></tr></table></figure><h3 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h3><p>每个Sentinel订阅了服务器的_sentinel_:hello频道，因此会收到其他sentinel发送的信息，进行对监视服务器信息的更新</p><p>这里更新的信息就是对sentinels字典的更新，简单来说就是有的实例则更新实例结构，若没有则添加</p><p>同时通过频道信息发现一个新的sentinel时，会为sentinel在sentinels字典中创建对应的实例结构，同时创建一个命令连接(用于主观下线检测和客观下线检测)</p><blockquote><p>我们知道sentinel之间可以通过频道通信，为什么还需要建立互相之间的命令连接呢？私认为，是使用场景不同，命令连接用于一对一，频道连接一对多</p></blockquote><h3 id="下线检测"><a href="#下线检测" class="headerlink" title="下线检测"></a>下线检测</h3><p>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例发送PING命令，并通过实例返回的PONG命令判断实例是否存活。如果超时未收到实例的响应信息，则认为主观下线</p><p>当一个sentinel认为检测的主服务器主观下线时，会发送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel is-master-down-by-addr xxx xxx </span><br></pre></td></tr></table></figure><p>给其他服务器，其他服务器会返回同意&#x2F;不同意下线，当收到总票数达到阈值qourum时则会认为该节点客观下线</p><p>当发生客观下线时，会进行sentinel选举，这里的选举算法就是raft算法</p><p>从raft的角度理解选举过程：</p><ol><li>每个sentinel都是follower，有机会成为leader</li><li>当发生sentinel选举的时候，会把sentinelInstance中的epoch + 1(类似termID)</li><li>candidate sentinel会向其他sentinel发送sentinel命令</li><li>follower sentinel投票的原则是先到先得，先接收到的会将sentinel设置为自己的局部leader</li><li>如果有半数以上的sentinel设置为局部领头sentinel，那么这个sentinel就会成为领头sentinel</li><li>同样的如果超时并未选出leader，则重新新选举</li></ol><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>故障转移包括三个步骤：</p><ol><li>在已下线的主服务器属下的所有从服务器里面，挑选初一个从服务器，并将其转化为主服务器</li><li>让已下线的主服务器属下的所有从服务器复制新的主服务器</li><li>将已下线的主服务器设置为新的主服务器的从服务器</li></ol><p>这里如何选择从服务器呢？</p><ol><li>保留所有数据比较新的从服务器</li><li>选择优先级高的服务器</li><li>选择偏移量大的服务器</li><li>选择runID小的服务器</li></ol><blockquote><p>这里可以看出来如果发生主服务器故障，会导致数据不一致，redis集群本身就是AP</p></blockquote><p>对选中的从服务器发送slave of no one(你自由啦！！！)<br>将其他从服务器发送slave of xxx(变为刚才服务器的从服务器)<br>当宕机的主服务器重新上线时发送slave of(也变为从服务器)</p>]]></content>
      
      
      <categories>
          
          <category> redis的设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simpledb-lab1</title>
      <link href="/2025/04/26/simpledb-lab1/"/>
      <url>/2025/04/26/simpledb-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="2022秋MIT6-830lab1实验报告"><a href="#2022秋MIT6-830lab1实验报告" class="headerlink" title="2022秋MIT6.830lab1实验报告"></a>2022秋MIT6.830lab1实验报告</h2><blockquote><p>在该实验中我们可以实现一个基础的database</p></blockquote><ul><li>what we will do in this lab? Tuple、TupleDesc、Catalog and so on</li><li>Remember what we dont do - <strong>transaction</strong>, <strong>locking</strong>, and <strong>recovery</strong></li></ul><h3 id="exercise1"><a href="#exercise1" class="headerlink" title="exercise1"></a>exercise1</h3><blockquote><p>在exercise1中我们需要实现Tuple和TupleDesc</p></blockquote><p><strong>Tuple</strong>: 指的是表中的一行数据，在实验中是由fields组成的，field指的是元数据？大概这么理解，实验中包括了int和string两种类型<br><strong>TupleDesc</strong>: 指的是一个表的行描述符，包括了字段名字和类型<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/7b0d901ab65d575bca987bcc864ab42.png" alt="Illustration"></p><p>可以看到Tuple类中有对TupleDesc类的引用，因此我们先实现TupleDesc<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/5404c55ca659ac45c72fa0e4e00f495.png" alt="TupleDesc"><br>在TupleDesc中已经帮我们实现了hepler class，我们使用一个collection操作TDItem即可</p><p>在Tuple这个类中，我们只需要使用Colletion操作Field即可</p><p><strong>Test Pass</strong>:</p><p><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/4a9c60f43926c3514d0208830cf5d27.png" alt="Tuple"><br>总体而言比较easy</p><h3 id="exercise2"><a href="#exercise2" class="headerlink" title="exercise2"></a>exercise2</h3><blockquote><p>exercise2要求我们实现catalog</p></blockquote><p>catalog就是数据库中用于索引一个表的目录，主要包括了该表的dbfile即磁盘存储，name即表名，pk即主键值。这里需要注意的是dbfile中的几个方法，getId()获取该表的唯一标识，getTd()获取该表描述符，这些方法在本次实验中会实现。</p><p>我们可以用一个map结构存储表，这里可以建立一个静态内部类帮我我们存储表相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static class Table &#123;</span><br><span class="line">    public DbFile file;</span><br><span class="line">    public String pkeyField;</span><br><span class="line"></span><br><span class="line">    public Table(DbFile file, String pkeyField) &#123;</span><br><span class="line">        this.file = file;</span><br><span class="line">        this.pkeyField = pkeyField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Table&gt; tables;</span><br></pre></td></tr></table></figure><p>其余方法按照hint实现即可</p><h3 id="exercise3"><a href="#exercise3" class="headerlink" title="exercise3"></a>exercise3</h3><blockquote><p>要求我们实现BufferPool的getPage方法</p></blockquote><p>首先我们需要理解BufferPool，在数据库中所有对数据的操作是基于BufferPool的，BufferPool是存放在内存中的，如果直接对磁盘中的数据进行操作IO消耗太大，因此我们可以理解为BufferPool提供了一个全局访问点，而在BufferPool中数据是以页的形式存储的，因此我们需要实现getPage方法提供获取数据页的接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final Map&lt;PageId, Page&gt; pages;</span><br><span class="line"></span><br><span class="line">public Page getPage(TransactionId tid, PageId pid, Permissions perm)</span><br><span class="line">        throws TransactionAbortedException, DbException &#123;</span><br><span class="line">    // hint: use DbFile.readPage() to access Page of a DbFile</span><br><span class="line">   if (!pages.containsKey(pid)) &#123;</span><br><span class="line">        if (pages.size() == numPages) throw new DbException(&quot;Buffer Pool has not space!&quot;);</span><br><span class="line">        DbFile file = Database.getCatalog().getDatabaseFile(pid.getTableId());</span><br><span class="line">        pages.put(pid, file.readPage(pid));</span><br><span class="line">   &#125;</span><br><span class="line">   return pages.get(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该实验中不要求实现BufferPool满后的缺页替换，只需要抛错即可。</p><p>PageId: 是一个page的唯一标识，可以通过PageId getTableId、getPageNumber</p><h3 id="exercise4"><a href="#exercise4" class="headerlink" title="exercise4"></a>exercise4</h3><blockquote><p>需要我们实现HeapPage HeapPageId RecordId</p></blockquote><p>首先我们可以梳理一下数据库中数据的存储结构了</p><ul><li>Field - 包括val和type，是最小的单元</li><li>Tuple - 是Collection of Field，代表一行数据 Tuple通过RecordId唯一标识，RecordId包括了getPageId() 和 getTupeNo()两方法</li><li>Page - 是Tuple的集合，同样的通过PageId唯一标识，包括了getTableId() 和 getPageNo() 两个方法</li><li>DbFile - 是Page的集合，DbFile代表了一张表在磁盘上的存储，通过getId()唯一标识一张表，同时还存储了表的描述符Td</li></ul><blockquote><p>Page Dbfile都是以接口抽象，因为存在多种存储形式，但是Tuple、RecordId是这些不同存储形式相同的底层行数据，行标识因此不用接口抽象</p></blockquote><p>依照上述整理我们一次实现RecordId</p><p>RecordId 内包含 PageId 和 tupleNo两个成员变量<br>HeapPageId 内包含 tableId 和 pageNo 两个成员变量</p><p>最后再实现HeapPage，这里HeapPage略微有点难度，这里给出我的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private int getNumTuples() &#123;</span><br><span class="line">    return (BufferPool.getPageSize() * 8) / (td.getSize() * 8 + 1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int getHeaderSize() &#123;</span><br><span class="line">    return (int)Math.ceil(getNumTuples() * 1.0 / 8);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这两个方法按照hint中的公式计算即可，注意getNumTuples这里需要化为double再除，否则会缺失</span><br><span class="line">public boolean isSlotUsed(int i) &#123;</span><br><span class="line">    // byte数组八个tuple一组，每个tuple在它所在的byte下标位标记</span><br><span class="line">    return ((header[i / 8] &gt;&gt; (i % 8)) &amp; 1) == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Iterator&lt;Tuple&gt; iterator() &#123;</span><br><span class="line">    return new Iterator&lt;Tuple&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        private int index = -1;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            if (index + 1 &lt; numSlots &amp;&amp; isSlotUsed(index + 1)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Tuple next() &#123;</span><br><span class="line">            return hasNext() ? tuples[++index] : null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void remove() throws UnsupportedOperationException&#123;</span><br><span class="line">            throw new UnsupportedOperationException(&quot;no impletion of this method&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exercise5"><a href="#exercise5" class="headerlink" title="exercise5"></a>exercise5</h3><blockquote><p>要求实现HeapFile</p></blockquote><p>HeapFile 即 DbFile的一种实现，对应一个数据表，那么包含File(磁盘上的File)、Td(磁盘描述符)</p><p>该实验的难点在于实现Iterator和ReadPage, 这里给出我的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> public Page readPage(PageId pid)&#123;</span><br><span class="line">    // 偏移量</span><br><span class="line">    long offset = pid.getPageNumber() * BufferPool.getPageSize();</span><br><span class="line">    byte[] data = new byte[BufferPool.getPageSize()];</span><br><span class="line">    Page page = null;</span><br><span class="line">    // Raf 随机访问文件</span><br><span class="line">    // Raf seek 跳过 offset字节数</span><br><span class="line">    // Raf read 读满 data数组</span><br><span class="line">    try (RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;))&#123;</span><br><span class="line">        raf.seek(offset);</span><br><span class="line">        raf.read(data);</span><br><span class="line">        page = new HeapPage((HeapPageId)pid, data);</span><br><span class="line">    &#125; catch(IOException e) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class HeapFileIterator implements DbFileIterator &#123;</span><br><span class="line"></span><br><span class="line">    private final TransactionId tid;</span><br><span class="line">    private int pgNo = 0;</span><br><span class="line">    private HeapPageId pid = new HeapPageId(getId(), pgNo);</span><br><span class="line">    private Iterator&lt;Tuple&gt; iterator;</span><br><span class="line">    private boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public HeapFileIterator(TransactionId tid) &#123;</span><br><span class="line">        this.tid = tid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() throws DbException, TransactionAbortedException &#123;</span><br><span class="line">        if (!flag) return false;</span><br><span class="line">        if (iterator.hasNext()) return true;</span><br><span class="line">        if (pgNo &lt; numPages() - 1) &#123;</span><br><span class="line">            pid = new HeapPageId(getId(), ++pgNo);</span><br><span class="line">            iterator = ((HeapPage)Database.getBufferPool().getPage(tid, pid, Permissions.READ_ONLY)).iterator();</span><br><span class="line">        &#125;</span><br><span class="line">        return iterator.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Tuple next() throws DbException, TransactionAbortedException,</span><br><span class="line">            NoSuchElementException &#123;</span><br><span class="line">        if (hasNext()) &#123;</span><br><span class="line">            return iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        throw new NoSuchElementException(&quot;no valid element!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void open() throws DbException, TransactionAbortedException &#123;</span><br><span class="line">        flag = true;</span><br><span class="line">        iterator = ((HeapPage)Database.getBufferPool().getPage(tid, pid, Permissions.READ_ONLY)).iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void rewind() throws DbException, TransactionAbortedException &#123;</span><br><span class="line">        pgNo = 0;</span><br><span class="line">        pid = new HeapPageId(getId(), pgNo);</span><br><span class="line">        iterator = ((HeapPage)Database.getBufferPool().getPage(tid, pid, Permissions.READ_ONLY)).iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里读取Tuple中需要读取对应的Page，其思想还是从BufferPool中读取，我们在前面已经实现了BufferPool的getPage，缺页时从DbFile的readPage获取</p><h3 id="exercise6"><a href="#exercise6" class="headerlink" title="exercise6"></a>exercise6</h3><blockquote><p>实现SeqScan</p></blockquote><p>该实验要求我们从数据库层面实现一种opt，即全表顺序扫描，我们已经层层封装了tuple的Iterator，在这里使用即可，比较easy</p><p>All Tests Pass<br><img src="https://yyhyy-blog.oss-cn-shanghai.aliyuncs.com/6b0457b81c676bd20141946630e6adf.png" alt="testResult"></p>]]></content>
      
      
      <categories>
          
          <category> simple-db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit </tag>
            
            <tag> database </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
